function [rPc,cPc] = detection_2 (A,rth,w,th)

% set parameters 
% w = 8;  % w is a integer larger than a single particle's apparent radius but smaller than the smallest inter-particle separation
% rth = 0.001;  % threshold for maxima selection, i.e. 100*rth % 
% lambdan = 1;  % camera discretization noise is modeled as uniformly Gaussian with correlation length of lambdan, usually set to unity (i.e. 1 pixel)
lambdan = (2*w+1)/(1+sqrt(2));  
lambdan1 = sqrt(2)*lambdan;  
% lambdan = 1;  
% lambdan1 = sqrt(2)*lambdan;  

sizA = size(A);
%% ========================================================================== 
% step 1: image restoration
%========================================================================== 
A = mat2gray(double(A));  % normalize A (i.e. 0<=A<=1)   
% set local region mask with some related often used variables
idx = -1*w : 1 : w; 
dm = 2*w + 1;  %  mask diameter
ijsm = ones(dm, dm);  % generate square mask  
ijcm = zeros(dm, dm);  % define circular mask  
im = repmat(idx', 1, dm);  % x coordinate matrx of mask
jm = repmat(idx, dm, 1);  % y coordinate matrx of mask 
i2j2sm = im .^ 2  + jm .^ 2;  % generate 2nd order square mask
ijcm((find(i2j2sm <= w*w))) = 1;  % generate circular mask 
i2j2cm = i2j2sm .* ijcm;  % generate 2nd order circular mask 
% build kernel Kw for background extraction and noise removal 
B = sum(exp(-1*((idx.^2)/(4*lambdan^2))))^2;  % eq.[3], also B = sum(sum(exp(-1*(i2j2sm/(4*ln^2))))) 
K0w = (1/B) * (sum(exp(-((idx.^2)/(2*lambdan^2))))^2) - (B/(dm^2));  % eq.[5], also K0w = (1/B) * sum(sum(exp(-1*(i2j2sm/(2*ln^2))))) - (B/(dm^2))
Kw = (1/K0w) * ((1/B) * exp(-(i2j2sm/(4*lambdan^2))) - (1/(dm^2)));  % eq.[4]
% apply convolution filter
Af0 = imfilter(A, Kw, 'replicate', 'same', 'conv');  % eq.[6]
Af0((find(Af0<0)))= 0;  % negative pixel values generated by the convolution are reset to 0 

B = sum(exp(-1*((idx.^2)/(4*lambdan1^2))))^2;  % eq.[3], also B = sum(sum(exp(-1*(i2j2sm/(4*ln^2))))) 
K0w = (1/B) * (sum(exp(-((idx.^2)/(2*lambdan1^2))))^2) - (B/(dm^2));  % eq.[5], also K0w = (1/B) * sum(sum(exp(-1*(i2j2sm/(2*ln^2))))) - (B/(dm^2))
Kw = (1/K0w) * ((1/B) * exp(-(i2j2sm/(4*lambdan1^2))) - (1/(dm^2)));  % eq.[4]
% apply convolution filter
Af1 = imfilter(A, Kw, 'replicate', 'same', 'conv');  % eq.[6]
Af1((find(Af1<0)))= 0;  % negative pixel values generated by the convolution are reset to 0 

Af = Af1- Af0;
Af((find(Af<0)))= 0;  % negative pixel values generated by the convolution are reset to 0 

% subplot(2,1,2);imshow(Af,[]);
% title('image restoration by Kw (Af)')
% 
%% ========================================================================== 
% step 2: estimate positions of feature particle 
%========================================================================== 
% determine upper rth% of intensity value as threshold for maxima selection
[cntAf, binAf] = imhist(Af);
l = length(cntAf);
k = 1;
while (sum(cntAf((l-k):l))/sum(cntAf)) < rth
      k = k + 1;
end;
% th = 0.5;
% identify local maxima in w-neighborhood which is larger than th as an individual particle's location
Pc = zeros(sizA);  % positions of candidate particle for refining 
Ad = imdilate(Af, ijcm);%ijcm是结构元素
[r, c] = find((Ad-Af)==0);  % the local maximum selection is implemented as a grayscale dilation followed by the selection of all pixels that have the same value before and after the dilation 
                            % rc = find((Ad-Af)==0)
vPc = find(Af(sub2ind(sizA, r, c))>th);  % vPc = find(Af(rcPc)>th)
rPc = r(vPc);  % row index of candidate particle                  
cPc = c(vPc);  % colum index of candidate particle, also [rPc,cPc] = ind2sub(sizA, rcPc(vPc))
Pc(sub2ind(sizA, rPc, cPc)) = 1;
% figure;imshow(Pc, [])
%% ========================================================================== 
% step 3: refine location estimates
%========================================================================== 
% 0 and 2th order intensity moment of all particles
nPc = length(rPc);
m0 = zeros(nPc,1);
m2 = zeros(nPc,1);
% compute 0 and 2th order intensity moment and position correction (epsx, epsy) for each particle 
for iPc = 1:nPc
    epsx = 1; 
    epsy = 1;
    nil = 0;  % prevent meanshift from falling into infinite loop 
    while or(abs(epsx)>0.5, abs(epsy)>0.5)
          nil = nil +1;
          if nil > dm^2  % if nil>area(ijsm)
             break
          end
	      % lower and upper index bounds for all particle neighborhoods in local coordinates, recalculate after every change in rPc and cPc 
	      li = 1-(rPc-w-saturate(rPc-w, 1, sizA(1)));
	      lj = 1-(cPc-w-saturate(cPc-w, 1, sizA(2)));
	      ui = dm-(rPc+w-saturate(rPc+w, 1, sizA(1)));
	      uj = dm-(cPc+w-saturate(cPc+w, 1, sizA(2)));
	      % masked image part containing the particle
	      Afij = Af(rPc(iPc)+li(iPc)-w-1:rPc(iPc)+ui(iPc)-w-1, cPc(iPc)+lj(iPc)-w-1:cPc(iPc)+uj(iPc)-w-1) .* ijcm(li(iPc):ui(iPc), lj(iPc):uj(iPc));
	      % intensity moment
	      m0(iPc) = sum(sum(Afij));  % eq.[8]  m0(iPc) = sum(Afij(:));
	      m2(iPc) = sum(sum(i2j2cm(li(iPc):ui(iPc), lj(iPc ):uj(iPc)) .* Afij))/m0(iPc);  % eq.[9]    
	      % position correction
 	      epsx = sum(sum(im(li(iPc):ui(iPc), lj(iPc):uj(iPc)) .* Afij))/m0(iPc);    % epsx = sum(idx(li(iPc):ui(iPc)).*sum(Afij'))/m0(iPc);
          epsy = sum(sum(jm(li(iPc):ui(iPc), lj(iPc):uj(iPc)) .* Afij))/m0(iPc);    % epsy = sum(idx(lj(iPc):uj(iPc)).*sum(Afij))/m0(iPc);
	      % if correction >0.5, move candidate location
	      if abs(epsx) > 0.5
	         rPc(iPc) = rPc(iPc) + sign(epsx);
          elseif abs(epsy) > 0.5
	             cPc(iPc) = cPc(iPc) + sign(epsy);
          end   
    end
end	
%% ========================================================================== 
% step 4: non-particle discrimination
%========================================================================== 
sigma0 = 0.1*max(Af(:))*pi*w^2;
sigma2 = 0.1*pi*w^4/2;
Prop = zeros(size(m0));
for i = 1:nPc  % nPc = Nt
    Prop(i) = sum(exp(-((m0(i)-m0).^2/(2*sigma0))-((m2(i)-m2).^2/(2*sigma2))))/(2*pi*sigma0*sigma2);
end
Sp = Prop - 1/(2*pi*sigma0*sigma2); 
Ts = mean(Sp);
Ts = 0.09 * Ts;
idp = find(Sp < Ts);  % indices of valid particles
idnp = find(Sp >= Ts);  % indices of unvalid particles
% pack data into return value
% cP = cPc(idp);  % col position  坐标系转换，为plot，line提供正确坐标系
% rP = rPc(idp);  % row position
% cnP = cPc(idnp);  % non-particle
% rnP = rPc(idnp);

%% ========================================================================== 
% 点检测算法优化，删除同一个点检出多次的情况
%========================================================================== 
[x,b] = sort(rPc); y = cPc(b);
a1 = x(1); b1 = y(1);
for i = 2:length(x)
    if x(i) == a1 & y(i) == b1
        x(i) = -1; y(i) = -1;
    else
        a1 = x(i);b1 = y(i);
    end
end
x(find(y<0)) = []; y(find(y<0)) = [];
rPc = x; cPc = y;
